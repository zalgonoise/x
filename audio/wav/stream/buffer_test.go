package stream_test

import (
	"bytes"
	"context"
	"errors"
	"io"
	"testing"
	"time"

	"github.com/zalgonoise/x/audio/fft"
	"github.com/zalgonoise/x/audio/osc"
	"github.com/zalgonoise/x/audio/wav"
	"github.com/zalgonoise/x/audio/wav/stream"
)

// sine8kHz is bytes for a 32bit WAV file with a header and PCM buffer, 44 + 1024 in size (header + PMC buffer)
//
// This data is a placeholder source of truth for testing FFT as a filter while the oscillator seems to drift
// on higher frequency values. It was generated in Audacity for better accuracy.
var sine8kHz = []byte{
	0x52, 0x49, 0x46, 0x46, 0xd0, 0x8d, 0x0, 0x0, 0x57, 0x41, 0x56, 0x45, 0x66, 0x6d, 0x74, 0x20, 0x10, 0x0, 0x0, 0x0,
	0x1, 0x0, 0x1, 0x0, 0x44, 0xac, 0x0, 0x0, 0x10, 0xb1, 0x2, 0x0, 0x4, 0x0, 0x20, 0x0, 0x64, 0x61, 0x74, 0x61, 0xac,
	0x8d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2b, 0x9, 0x5d, 0x0, 0x32, 0xbc, 0x4d, 0xe0, 0x3d, 0xea, 0xe3, 0x80, 0x79,
	0xcc, 0x9a, 0x0, 0xfc, 0x86, 0xc7, 0x80, 0x1c, 0x4, 0x36, 0x80, 0xf4, 0x9a, 0x65, 0x0, 0x15, 0xe1, 0x1e, 0x80, 0xe,
	0x32, 0xb4, 0x0, 0x7a, 0xc8, 0xa1, 0x4, 0x1e, 0x15, 0xfd, 0x0, 0x79, 0xc7, 0x5b, 0x0, 0x4a, 0x9a, 0x4f, 0x20, 0x67,
	0xbb, 0xe6, 0x80, 0xf0, 0x48, 0x9b, 0x80, 0xd1, 0x1d, 0xc5, 0x0, 0xfb, 0x83, 0x33, 0x0, 0x44, 0xed, 0x65, 0xc0, 0xfc,
	0xa5, 0x21, 0x80, 0x10, 0x30, 0xb6, 0x0, 0xb4, 0xad, 0xa0, 0x48, 0xd7, 0x2a, 0xfa, 0x0, 0xb4, 0x72, 0x5a, 0x0, 0xd7,
	0x67, 0x51, 0xe0, 0xd0, 0x91, 0xe9, 0x0, 0x56, 0xda, 0x9b, 0x40, 0xe4, 0xc0, 0xc2, 0x0, 0x24, 0xf9, 0x30, 0x0, 0x64,
	0x2a, 0x66, 0x0, 0xe6, 0x63, 0x24, 0x0, 0x6a, 0x3d, 0xb8, 0x0, 0xbe, 0xa6, 0x9f, 0xe0, 0xc6, 0x41, 0xf7, 0x0, 0x22,
	0xb, 0x59, 0x80, 0x77, 0x24, 0x53, 0x20, 0xe4, 0x6c, 0xec, 0x0, 0x8d, 0x80, 0x9c, 0xc0, 0xb1, 0x70, 0xc0, 0x80, 0x1f,
	0x64, 0x2e, 0x0, 0x48, 0x52, 0x66, 0x0, 0x3f, 0x1a, 0x27, 0x0, 0xae, 0x59, 0xba, 0x0, 0xcf, 0xb3, 0x9e, 0xc0, 0x87,
	0x5a, 0xf4, 0x0, 0xe, 0x91, 0x57, 0x80, 0xd0, 0xcf, 0x54, 0x0, 0x9, 0x4c, 0xef, 0x0, 0x72, 0x3b, 0x9d, 0x80, 0xb5,
	0x2d, 0xbe, 0x80, 0x76, 0xc5, 0x2b, 0x80, 0xe7, 0x64, 0x66, 0x80, 0x77, 0xc8, 0x29, 0x0, 0x6c, 0x84, 0xbc, 0x0, 0x19,
	0xd5, 0x9d, 0x40, 0xb4, 0x75, 0xf1, 0x80, 0xc6, 0x4, 0x56, 0x0, 0x89, 0x69, 0x56, 0xa0, 0xa6, 0x2e, 0xf2, 0x80, 0xde,
	0xa, 0x9e, 0x80, 0x67, 0xf8, 0xbb, 0x40, 0xb4, 0x1d, 0x29, 0x0, 0x3e, 0x62, 0x66, 0x80, 0x0, 0x6e, 0x2c, 0x0, 0x31,
	0xbd, 0xbe, 0x80, 0xca, 0xa, 0x9d, 0x80, 0xe6, 0x93, 0xee, 0x0, 0x9e, 0x66, 0x54, 0x0, 0x4b, 0xf1, 0x57, 0x70, 0x23,
	0x14, 0xf5, 0x80, 0xa7, 0xee, 0x9e, 0x0, 0x3d, 0xd1, 0xb9, 0x40, 0x66, 0x6d, 0x26, 0x0, 0x4d, 0x4a, 0x66, 0x80, 0x4d,
	0xa, 0x2f, 0x0, 0x86, 0x3, 0xc1, 0x80, 0xd, 0x55, 0x9c, 0xc0, 0xb7, 0xb5, 0xeb, 0x80, 0xea, 0xb6, 0x52, 0x80, 0xc5,
	0x66, 0x59, 0x70, 0xe5, 0xfb, 0xf7, 0x0, 0x9d, 0xe6, 0x9f, 0x80, 0xa9, 0xb8, 0xb7, 0x80, 0x1b, 0xb5, 0x23, 0x80, 0x19,
	0x1d, 0x66, 0x80, 0xd3, 0x9c, 0x31, 0xc0, 0xf2, 0x56, 0xc3, 0x0, 0x8, 0xb4, 0x9b, 0xa0, 0xc0, 0xdb, 0xe8, 0x0, 0x6,
	0xf6, 0x50, 0x0, 0xab, 0xc9, 0x5a, 0xf0, 0x51, 0xe5, 0xfa, 0x0, 0x8c, 0xf2, 0xa0, 0x80, 0x1b, 0xaf, 0xb5, 0x0, 0x65,
	0xf5, 0x20, 0x0, 0xac, 0xda, 0x65, 0x80, 0x9, 0x25, 0x34, 0x40, 0xfb, 0xb6, 0xc5, 0x0, 0xdb, 0x27, 0x9b, 0xe0, 0x98,
	0x6, 0xe6, 0x80, 0x4d, 0x24, 0x4f, 0x0, 0xb2, 0x19, 0x5c, 0x4, 0xce, 0xcf, 0xfd, 0x0, 0x3d, 0x12, 0xa2, 0x0, 0x0,
	0xb5, 0xb3, 0x80, 0xd4, 0x2e, 0x1e, 0x0, 0x13, 0x83, 0x65, 0x0, 0x69, 0xa2, 0x36, 0x40, 0x21, 0x23, 0xc8, 0x0, 0xa4,
	0xb0, 0x9a, 0x40, 0xd7, 0x36, 0xe3, 0x80, 0x21, 0x42, 0x4d, 0x0, 0x94, 0x56, 0x5d, 0x8f, 0xbe, 0xba, 0x0, 0x0, 0x74,
	0x45, 0xa3, 0x0, 0xc0, 0xca, 0xb1, 0x0, 0xfe, 0x61, 0x1b, 0x0, 0x61, 0x16, 0x65, 0x40, 0x6d, 0x14, 0x39, 0x80, 0xe3,
	0x9a, 0xca, 0x0, 0x7c, 0x4e, 0x9a, 0x40, 0x11, 0x6d, 0xe0, 0x0, 0xe7, 0x4f, 0x4b, 0x0, 0x10, 0x80, 0x5e, 0x48, 0x88,
	0xa5, 0x3, 0x0, 0xf1, 0x8b, 0xa4, 0x80, 0xc1, 0xf0, 0xaf, 0xa0, 0x76, 0x8f, 0x18, 0x80, 0xab, 0x94, 0x64, 0x80, 0x94,
	0x7a, 0x3b, 0x0, 0xbf, 0x1d, 0xcd, 0x0, 0x77, 0x1, 0x9a, 0x80, 0xdb, 0xa9, 0xdd, 0x0, 0x5, 0x4e, 0x49, 0x0, 0xe7,
	0x95, 0x5f, 0xf8, 0x8f, 0x8f, 0x6, 0x80, 0x70, 0xe5, 0xa5, 0x0, 0x67, 0x27, 0xae, 0x40, 0xd4, 0xb7, 0x15, 0x80, 0xe,
	0xfe, 0x63, 0xc0, 0x5e, 0xd4, 0x3d, 0x0, 0x2e, 0xab, 0xcf, 0x0, 0xa5, 0xc9, 0x99, 0x80, 0xc8, 0xed, 0xda, 0x80, 0xe6,
	0x3c, 0x47, 0x80, 0xe0, 0x97, 0x60, 0x90, 0x3a, 0x78, 0x9, 0x0, 0xaa, 0x51, 0xa7, 0x0, 0x10, 0x6f, 0xac, 0x60, 0xae,
	0xdb, 0x12, 0x80, 0xa8, 0x52, 0x63, 0x0, 0x4f, 0x21, 0x40, 0xc0, 0xa8, 0x42, 0xd2, 0x80, 0x11, 0xa7, 0x99, 0x40, 0x6a,
	0x39, 0xd8, 0x80, 0xf9, 0x1c, 0x45, 0x0, 0xc6, 0x85, 0x61, 0x40, 0xed, 0x5e, 0xc, 0x0, 0x52, 0xd0, 0xa8, 0x0, 0x17,
	0xc8, 0xaa, 0xf0, 0x9c, 0xfb, 0xf, 0x0, 0x9e, 0x92, 0x62, 0x0, 0xeb, 0x60, 0x42, 0x40, 0xa5, 0xe3, 0xd4, 0x0, 0xc4,
	0x99, 0x99, 0x40, 0x50, 0x8d, 0xd5, 0x0, 0xaf, 0xee, 0x42, 0x0, 0x66, 0x5f, 0x62, 0xb0, 0xd, 0x43, 0xf, 0x0, 0x1a,
	0x61, 0xaa, 0x80, 0xd4, 0x32, 0xa9, 0x20, 0x39, 0x18, 0xd, 0x0, 0x16, 0xbe, 0x61, 0x0, 0xbb, 0x92, 0x44, 0xc0, 0x97,
	0x8d, 0xd7, 0x80, 0xbf, 0xa1, 0x99, 0x40, 0x9, 0xea, 0xd2, 0x0, 0x7b, 0xb2, 0x40, 0x0, 0x94, 0x24, 0x63, 0x20, 0x2,
	0x24, 0x12, 0x0, 0xad, 0x3, 0xac, 0x80, 0x9c, 0xaf, 0xa7, 0x80, 0x1c, 0x32, 0xa, 0x80, 0x3d, 0xd5, 0x60, 0x80, 0x4a,
	0xb6, 0x46, 0x40, 0xf2, 0x3f, 0xda, 0x0, 0x2, 0xbf, 0x99, 0x0, 0x21, 0x50, 0xd0, 0x40, 0xd4, 0x68, 0x3e, 0x80, 0x26,
	0xd5, 0x63, 0x40, 0x31, 0x1, 0x15, 0x80, 0xb5, 0xb7, 0xad, 0x0, 0xc0, 0x3e, 0xa6, 0x68, 0xe1, 0x49, 0x7, 0x80, 0x44,
	0xd8, 0x5f, 0x0, 0x27, 0xcb, 0x48, 0xc0, 0x25, 0xfa, 0xdc, 0x0, 0x85, 0xf1, 0x99, 0x40, 0x22, 0xc0, 0xcd, 0xc0, 0x34,
	0x12, 0x3c, 0x0, 0xf9, 0x70, 0x64, 0xa0, 0x2, 0xda, 0x17, 0x0, 0xd8, 0x7c, 0xaf, 0x80, 0x8b, 0xe0, 0xa4, 0x78, 0x22,
	0x60, 0x4, 0x80, 0x5f, 0xc7, 0x5e, 0x0, 0xe2, 0xd0, 0x4a, 0x80, 0xa0, 0xbb, 0xdf, 0x80, 0x3e, 0x39, 0x9a, 0x40, 0x95,
	0x3a, 0xcb, 0x0, 0x19, 0xaf, 0x39, 0x0, 0xeb, 0xf7, 0x64, 0x0, 0xdf, 0xad, 0x1a, 0x80, 0xb6, 0x52, 0xb1, 0x80, 0x47,
	0x95, 0xa3, 0xb2, 0x7a, 0x75, 0x1, 0x0, 0xc7, 0xa2, 0x5d, 0x80, 0x10, 0xc7, 0x4c, 0x60, 0xd0, 0x83, 0xe2, 0x0, 0x20,
	0x96, 0x9a, 0x40, 0x0, 0xc0, 0xc8, 0xc0, 0xff, 0x3f, 0x37, 0x0, 0xe0, 0x69, 0x65, 0xa0, 0x2f, 0x7c, 0x1d, 0x80, 0xef,
	0x38, 0xb3, 0x0, 0x39, 0x5d, 0xa2, 0x4e, 0x85, 0x8a, 0xfe, 0x80, 0xb8, 0x6a, 0x5c, 0x80, 0x49, 0xad, 0x4e, 0x0, 0x21,
	0x52, 0xe5, 0x0, 0x15, 0x8, 0x9b, 0x0, 0xe7, 0x50, 0xc6, 0xc0, 0x6a, 0xc5, 0x34, 0x80, 0xc1, 0xc6, 0x65, 0x80, 0x5f,
	0x44, 0x20, 0x0, 0x1e, 0x2f, 0xb5, 0x80, 0xa0, 0x38, 0xa1, 0x88, 0xdd, 0x9f, 0xfb, 0x80, 0x74, 0x1f, 0x5b, 0x0, 0x28,
	0x83, 0x50, 0x60, 0xfd, 0x25, 0xe8, 0x0, 0x7, 0x8f, 0x9b, 0x40, 0xcb, 0xed, 0xc3, 0xc0, 0xdd, 0x3f, 0x32, 0x0, 0x7b,
	0xe, 0x66, 0x40, 0xda, 0x5, 0x23, 0x0, 0xd9, 0x34, 0xb7, 0x80, 0xbb, 0x27, 0xa0, 0x98, 0x1e, 0xb6, 0xf8, 0x0, 0x40,
	0xc1, 0x59, 0x80, 0x4a, 0x48, 0x52, 0xc0, 0xce, 0xfe, 0xea, 0x80, 0xd9, 0x2a, 0x9c, 0xc0, 0x2b, 0x97, 0xc1, 0x0, 0xdf,
	0xaf, 0x2f, 0x0, 0xfe, 0x40, 0x66,
}

func newSine(freq int) (*wav.Wav, error) {
	// create a sine wave 16 bit depth, 44.1kHz rate, mono,
	// 5 second duration. Pass audio bytes into a new bytes.Buffer
	sine, err := wav.New(44100, 16, 1, 1)
	if err != nil {
		return nil, err
	}
	sine.Generate(osc.SineWave, freq, 5*time.Second)
	return sine, nil
}

func TestWavBuffer(t *testing.T) {
	t.Run("Success", func(t *testing.T) {
		t.Run("MaxValues", func(t *testing.T) {
			// expect test to be faster than the actual length of the generated audio
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*300)
			defer cancel()

			buf := bytes.NewReader(sine8kHz)

			// create a channel to read the max values emitted by the filter
			var maxCh = make(chan int, 2)
			defer close(maxCh)
			go func() {
				for i := range maxCh {
					t.Log(i)
				}
			}()

			// create a new stream using the bytes.Buffer as an io.Reader
			// half a second ratio (expect 11 entries), with a max values filter
			w := stream.New(buf).
				Ratio(0.5).
				WithFilter(
					stream.MaxValues(maxCh),
				)

			// stream the audio using the context and an err channel
			errCh := make(chan error)
			defer close(errCh)
			go w.Stream(ctx, errCh)

			// wait for the stream processing to end
			// expect an error (io.EOF) when the stream is consumed
			//
			// in case the context is done before an error is received,
			// it's surely a deadline reached error, as the test took too long
			select {
			case err := <-errCh:
				if errors.Is(err, io.EOF) {
					return
				}
				t.Errorf("unexpected error: wanted %v ; got %v", io.EOF, err)
				return
			case <-ctx.Done():
				err := ctx.Err()
				if err != nil {
					t.Error(err)
					return
				}
			}
		})

		t.Run("FFTOnThreshold", func(t *testing.T) {
			// expect test to be faster than the actual length of the generated audio
			// create a channel to read the max values emitted by the filter

			var (
				ctx, cancel      = context.WithTimeout(context.Background(), time.Second*30)
				maxCh            = make(chan fft.FrequencyPower, 5)
				detectionCounter int
				targetFreq       = 8000
				drift            = 300
			)

			defer cancel()
			defer close(maxCh)

			buf := bytes.NewReader(sine8kHz)

			// goroutine to verify emitted FrequencyPower objects
			go func() {
				for i := range maxCh {
					if i.Freq < targetFreq-drift || i.Freq > targetFreq+drift {
						t.Errorf("frequency is off: emitted %dHz ; got %dHz", targetFreq, i.Freq)
					}
					detectionCounter++
				}
			}()

			// create a new stream using the bytes.Buffer as an io.Reader
			w := stream.New(buf).
				WithFilter(
					stream.FFTOnThreshold(fft.Block256, 10, maxCh),
				).BlockSize(1024)

			// stream the audio using the context and an err channel
			errCh := make(chan error)
			defer close(errCh)
			go w.Stream(ctx, errCh)

			// wait for the stream processing to end
			// expect an error (io.EOF) when the stream is consumed
			//
			// in case the context is done before an error is received,
			// it's surely a deadline reached error, as the test took too long
			select {
			case err := <-errCh:
				if !errors.Is(err, io.EOF) {
					t.Errorf("unexpected error: wanted %v ; got %v", io.EOF, err)
					return
				}
				if detectionCounter == 0 {
					t.Errorf("expected detector to increase in value during the test")
				}
				return
			case <-ctx.Done():
				err := ctx.Err()
				if err != nil {
					t.Error(err)
					return
				}
			}
		})
	})

	t.Run("FailNoHeader", func(t *testing.T) {
		// expect test to be faster than the actual length of the generated audio
		ctx, cancel := context.WithTimeout(context.Background(), time.Second*2)
		defer cancel()

		// sine wave stream for testing
		sine, err := newSine(2000)
		if err != nil {
			t.Error(err)
			return
		}
		buf := bytes.NewBuffer(sine.Data.Bytes())

		// create a channel to read the max values emitted by the filter
		var maxCh = make(chan int, 2)
		defer close(maxCh)
		go func() {
			for i := range maxCh {
				t.Log(i)
			}
		}()

		// create a new stream using the bytes.Buffer as an io.Reader
		w := stream.New(buf)

		// stream the audio using the context and an err channel
		errCh := make(chan error)
		defer close(errCh)
		go w.Stream(ctx, errCh)

		// wait for the stream processing to end
		// expect an error (io.EOF) when the stream is consumed
		//
		// in case the context is done before an error is received,
		// it's surely a deadline reached error, as the test took too long
		select {
		case err := <-errCh:
			if errors.Is(err, wav.ErrInvalid) && errors.Is(err, wav.ErrHeader) {
				return
			}
			t.Errorf("unexpected error: wanted %v ; got %v", wav.ErrInvalidHeader, err)
			return
		case <-ctx.Done():
			err := ctx.Err()
			if err != nil {
				t.Error(err)
				return
			}
		}
	})
}
